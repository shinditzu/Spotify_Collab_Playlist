from dotenv import load_dotenv
from datetime import datetime
import json
import os
from Openai import OpenAI
import yaml

load_dotenv()

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"),
                )
model = os.getenv('OPENAI_MODEL', 'gpt-4o')

def create_asana_task(task_name, due_on="today"):
    """
    Creates a task in Asana given the name of the task and when it is due

    Example call:

    create_asana_task("Test Task", "2024-06-24")
    Args:
        task_name (str): The name of the task in Asana
        due_on (str): The date the task is due in the format YYYY-MM-DD. If not given, the current day is used
    Returns:
        str: The API response of adding the task to Asana or an error message if the API call threw an error
    """
    if due_on == "today":
        due_on = str(datetime.now().date())

    task_body = {
        "data": {
            "name": task_name,
            "due_on": due_on,
            "projects": [os.getenv("ASANA_PROJECT_ID", "")]
        }
    }

    # try:
    #     api_response = tasks_api_instance.create_task(task_body, {})
    #     return json.dumps(api_response, indent=2)
    # except ApiException as e:
    #     return f"Exception when calling TasksApi->create_task: {e}"
    

def get_tools():
    tools = [
        {
            "type": "function",
            "function": {
                "name": "create_asana_task",
                "description": "Creates a task in Asana given the name of the task and when it is due",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "task_name": {
                            "type": "string",
                            "description": "The name of the task in Asana"
                        },
                        "due_on": {
                            "type": "string",
                            "description": "The date the task is due in the format YYYY-MM-DD. If not given, the current day is used"
                        },
                    },
                    "required": ["task_name"]
                },
            },
        }
    ]

def prompt_ai(messages):
    # First, prompt the AI with the latest user message
    completion = client.chat.completions.create(
        model=model,
        messages=messages,
        #tools=get_tools()
    )

    response_message = completion.choices[0].message
    tool_calls = response_message.tool_calls

    # Second, see if the AI decided it needs to invoke a tool
    if tool_calls:
        # If the AI decided to invoke a tool, invoke it
        available_functions = {
            "create_asana_task": create_asana_task
        }

        # Add the tool request to the list of messages so the AI knows later it invoked the tool
        messages.append(response_message)

        # Next, for each tool the AI wanted to call, call it and add the tool result to the list of messages
        for tool_call in tool_calls:
            function_name = tool_call.function.name
            function_to_call = available_functions[function_name]
            function_args = json.loads(tool_call.function.arguments)
            function_response = function_to_call(**function_args)

            messages.append({
                "tool_call_id": tool_call.id,
                "role": "tool",
                "name": function_name,
                "content": function_response
            })

        # Call the AI again so it can produce a response with the result of calling the tool(s)
        second_response = client.chat.completions.create(
            model=model,
            messages=messages,
        )

        return second_response.choices[0].message.content

    return response_message.content

def build_netbox_device_types(model=None):
    pass

def bot_generate_device_type(device_model):
    messages = [
        {
            "role": "system",
            "content": f"""You are a personal assistant who helps build netbox YAML device types.
            You will parse the netbox device-type library at https://github.com/netbox-community/devicetype-library/ first. 
            If a given model does not exist here, you will retrieve datacenter device information from vendor datasheets and respond with properly formed YAML for NetBox.
            Indentation in your response needs to be correct. 
            If you are building a device type, you will always match the Model Name and the part number to the device model. 
            The slug will be the model name in lowercase with spaces replaced by underscores and slashes replaced by underscores.
            Include the power plug type and power draw if it is available.
            Include links to your sources in the comments section of the YAML along with any other relevant information.
            The model you will use is {device_model}."""
        }
    ]
    
    ai_response = prompt_ai(messages)

    print(ai_response)

    if ai_response and '```yaml' in ai_response:
        yaml_in = ai_response.split('```yaml')[1].split('```')[0]
        data = yaml.safe_load(yaml_in)
        yaml_content = yaml.dump(data, sort_keys=False, default_flow_style=False)

        # Write the YAML content to a file
        if not os.path.exists('bot_generated_devicetypes'):
            os.makedirs('bot_generated_devicetypes')

        # Create a filename based on the device model
        filename = device_model.lower().replace(' ', '_').replace('/', '_') + '.yaml'
        with open(f'bot_generated_devicetypes/{filename}', 'w') as f:
            f.write(yaml_content)
        print(yaml_content)
        print(f"YAML content written to bot_generated_devicetypes/{filename}")
    else:
        print("No YAML content found in the AI response.")


def main():
    pass

if __name__ == "__main__":
    main()